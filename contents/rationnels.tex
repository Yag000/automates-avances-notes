
\section{Langages Rationnels}


\digraph[scale=0.5]{langage}{
	rankdir=TB;

	Node0 [shape=ellipse, style=filled, color=lightblue, label=<Langages<br/>rationnels>];
	Node1 [shape=ellipse, style=filled, color=lightgreen, label=<Automates finis<br/>déterministes>];
	Node2 [shape=ellipse, style=filled, color=lightgreen, label=<Automates finis<br/>non déterministes<br/>+ ε-transitions>];
	Node3 [shape=ellipse, style=filled, color=lightgreen, label=<Expressions<br/>rationnelles>];
	Node4 [shape=ellipse, style=filled, color=lightgreen, label=<Logique monadique<br/>du second ordre>];
	Node5 [shape=ellipse, style=filled, color=lightgreen, label=<Théorie<br/>des monoïdes>];

	Node0 -> Node1;
	Node0 -> Node2;
	Node0 -> Node3;
	Node0 -> Node4;
	Node0 -> Node5;
}

\subsection{Définitions de base}

\begin{definition}[alphabet]
	Un \textbf{alphabet} est un ensemble fini de lettres ou de symboles.
\end{definition}

\begin{definition}[mot]
	Un \textbf{mot} sur un alphabet $\alphabet$ est une séquence de lettres de $\alphabet$.
	On écrit $\motDecomp w n$ où $w_i \in \alphabet, \forall i \in \{1, \ldots, n\}$.
	La longueur d'un mot $w$ est notée $\len w = n$, pour $\motDecomp w n$.
\end{definition}

\begin{notation}
	On note $\motvide$ le mot vide et $\mots$ l'ensemble des mots sur $\alphabet$.
\end{notation}

\begin{definition}[concaténation]
	La \textbf{concaténation} de deux mots $w$ et $v$ est notée $wv$.
	Si $\motDecomp w n$ et $\motDecomp v m$, alors $wv = \decomp w n \decomp v m$.
\end{definition}

\begin{definition}[langage]
	Un langage sur un alphabet $\alphabet$ est un sous-ensemble de $\mots$.
\end{definition}

\begin{definition}[concaténation de langages]
	Soient $L_1, L_2$ deux langages sur $\alphabet$, leur \textbf{concaténation} est le langage
	\[
		L_1L_2 = \setdef {w_1w_2} {w_1 \in L_1, w_2 \in L_2}
	\]
\end{definition}

\begin{exemple}
	$$ \alphabet = \set{a, b}, \quad L = \set{\red a, \red {ab}, \red{bb}}, \quad K = \set{\blue b, \blue {ab}} $$
	$$ LK = \set{\red a \blue b, \red {ab} \blue b, \red {bb} \blue b, \red a \blue{ab}, \red {ab} \blue {ab}, \red {bb} \blue {ab}} $$
\end{exemple}


\begin{definition}[étoile de Kleene]
	Soit $L$ un langage sur $\alphabet$, son \textbf{étoile de Kleene} est le langage
	$$
		\kleene L = \bigcup_{n \in \N} L^n
	$$
	où $L^0 = \set\motvide$ et $L^{n+1} = LL^n$.
\end{definition}

\begin{remarque}
	Est-ce que $\kleene L = \setdef {w^n} {w \in L, n \in \N}$ ?

	Non, on peut trouver un contre-exemple avec $L = \set{a, b}$.

	On a bien que $ab \in \kleene L$, mais $ab \notin \setdef {w^n} {w \in L, n \in \N} = \setdef {a^n} {n \in \N} \cup \setdef {b^n} {n \in \N}$.
\end{remarque}

\begin{remarque}
	Est-ce que $L(M \cap N) = LM \cap LN$ ?

	Non, on peut trouver un contre-exemple avec $L = \set{a, ab}$, $M = \set{b}$ et $N = \set{\motvide}$.

	On a que $M \cap N = \emptyset$, donc $L(M \cap N) = \emptyset$.

	Mais $LM = \set{ab, abb}$ et $LN = \set{a, ab}$, donc $LM \cap LN = \set{ab} \neq \emptyset$.
\end{remarque}

\begin{exercice}
	Montrer que la concaténation de langages est distributive par rapport à l'union, \ie que $L(M \cup N) = LM \cup LN, \forall L, M, N$ langages.
\end{exercice}

\subsection{Langages rationnels : définitions}

\begin{definition}[langage rationnel]
	Soit $\alphabet$ un alphabet fini, l'ensemble \eratsym \ des expressions rationnelles sur $\alphabet$ est défini comme suit :
	\begin{itemize}
		\item $\motvide \in \eratsym$
		\item $\emptyset \in \eratsym$
		\item $\forall a \in \alphabet, a \in \eratsym$
		\item $\forall E, F \in \eratsym, E + F \in \eratsym$
		\item $\forall E, F \in \eratsym, EF \in \eratsym$
		\item $\forall E \in \eratsym, \kleene E \in \eratsym$
	\end{itemize}
\end{definition}

\begin{definition}[sémantique des expressions rationnelles]
	Soit $r \in \erat$, on définit le langage $\lang r$ associé à $r$ par induction sur la structure de $r$ :
	\begin{itemize}
		\item $\lang \motvide = \set\motvide$
		\item $\lang \emptyset = \emptyset$
		\item $\lang a = \set a$
		\item $\lang {E + F} = \lang E \cup \lang F$
		\item $\lang {EF} = \lang E \lang F$
		\item $\lang {\kleene E} = \kleene {\lang E}$
	\end{itemize}
\end{definition}

\begin{exemple}
	$ \alphabet = \set{a, b}, \quad r = \kleene {(a + b)} a \in \erat $, alors
	$ \lang r = \setdef {wa} {w \in \mots} $
\end{exemple}


\begin{definition}[langage rationnel]
	Un langage $L$ sur un alphabet $\alphabet$ est dit \textbf{rationnel} s'il existe une \exprat $r \in \erat$ \tlq $L = \lang r$.

\end{definition}

\begin{exemple}
	$\setdef {a^n} {n \in \N}$ est un langage rationnel engendré par l'expression rationnelle $\kleene a$.

	Cependant, $\setdef {a^n b^n} {n \in \N}$ n'est pas un langage rationnel.
\end{exemple}


\subsection{Automates finis}

\subsubsection{Automates finis déterministes}

\begin{definition}[automate fini déterministe]
	Soit $\alphabet$ un alphabet, un \textbf{automate fini déterministe} (AFD) est un tuple $\AFD$ où
	\begin{itemize}
		\item $Q$ est un ensemble fini d'états
		\item $q_0 \in Q$ est appelé l'état initial
		\item $F \subseteq Q$ est l'ensemble des états finaux / acceptants
		\item $\delta : Q \times \alphabet \to Q$ est la fonction de transition
	\end{itemize}
\end{definition}


\begin{exemple} Un automate fini déterministe :

	\vspace{0.5cm}
	\begin{minipage}{0.5\textwidth}
		\begin{itemize}
			\item $\alphabet = \set{a, b}$
			\item $Q = \set{q_0, q_1}$
			\item $q_0$ est l'état initial
			\item $F = \set{q_0, q_1}$
			\item $\delta :
				      \left\{
				      \begin{array}{cc}
					      (q_0, a) & \mapsto q_0 \\
					      (q_0, b) & \mapsto q_1 \\
					      (q_1, a) & \mapsto q_0 \\
					      (q_1, b) & \mapsto q_1 \\
				      \end{array}
				      \right.$
		\end{itemize}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\digraph[scale=0.75]{automateDet}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="q_0"];
			q1 [label="q_1"];

			start [shape=point];
			start -> q0;

			q0 -> q0 [label="a"];
			q0 -> q1 [label="b"];
			q1 -> q1 [label="b"];
			q1 -> q0 [label="a"];

			q0 [shape=doublecircle];
			q1 [shape=doublecircle];
		}
	\end{minipage}
\end{exemple}

\begin{definition}[lecture d'un mot par un AFD]
	Soit $A = \AFD$ un AFD qui a pour alphabet $\alphabet$. On définit la fonction $\kleene \delta$ par induction sur la longueur du mot $w$ :
	$$ \begin{array}{rcl}
			\kleene \delta : Q \times \mots & \to     & Q                               \\
			(q, \motvide)                   & \mapsto & q                               \\
			(q, wa)                         & \mapsto & \delta(\kleene \delta(q, w), a)
		\end{array} $$
	On a alors que $\kleene \delta(q, w)$ est l'état atteint par $A$ après avoir lu le mot $w$ depuis l'état $q$.
\end{definition}

\begin{definition}[langage reconnu par un AFD]
	Le langage reconnu / accepté par un AFD $A = \AFD$ est le langage
	$$ \lang A = \setdef w {w \in \mots, \kleene \delta(q_0, w) \in F} $$
\end{definition}

\begin{exemple}
	Pour l'automate $A$ suivant, avec $\alphabet = \set {a,b}$, le langage reconnu est $\lang A = \lang {\kleene {(a + b)} b} = \lang {\kleene {(a + b)} b \kleene b} = \setdef {wb} {w \in \mots}$.

	\begin{center}
		\digraph[scale=0.75]{automateDet2}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="q_0"];
			q1 [label="q_1"];

			start [shape=point];
			start -> q0;

			q0 -> q0 [label="a"];
			q0 -> q1 [label="b"];
			q1 -> q1 [label="b"];
			q1 -> q0 [label="a"];

			q1 [shape=doublecircle];
		}
	\end{center}
\end{exemple}

\subsubsection{Automates finis non déterministes \darkgreen{+ $\motvide$-transitions}}

\begin{definition}[automate fini non déterministe \darkgreen{+ $\motvide$-transitions}]
	Soit $\alphabet$ un alphabet, un \textbf{automate fini non déterministe} (AFN) est un tuple $\AFN$ où
	\begin{itemize}
		\item $Q$ est un ensemble fini d'états
		\item $I \subseteq Q$ est l'ensemble des états initiaux
		\item $F \subseteq Q$ est l'ensemble des états finaux / acceptants
		\item $\delta : Q \times (\alphabet \darkgreen {\ \cup \set\motvide}) \to \mathcal{P}(Q)$ est la fonction de transition
	\end{itemize}
\end{definition}


\begin{exemple}
	Un automate fini non déterministe avec $\alphabet = \set{a, b}$ :
	\begin{center}
		\digraph[scale=0.65]{automateNonDet}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="q_0"];
			q1 [label="q_1"];
			q2 [label="q_2"];

			start [shape=point];
			start -> q0;

			q0 -> q0 [label="b"];
			q0 -> q1 [label="a"];
			q1 -> q1 [label="b"];
			q1 -> q0 [label="b"];
			q0 -> q2 [label="a"];
			q2 -> q2 [label="b"];

			q1 [shape=doublecircle];
			q2 [shape=doublecircle];
		}
	\end{center}
\end{exemple}


\begin{definition}[lecture d'un mot par un AFN]
	Soit $A = \AFN$ un AFN qui a pour alphabet $\alphabet$. On définit la fonction $\kleene \delta$ par induction sur la longueur du mot $w$ :
	$$ \begin{array}{rcl}
			\kleene \delta : Q \times \mots & \to     & \parts Q                                                  \\
			(q, \motvide)                   & \mapsto & \set q                                                    \\
			(q, wa)                         & \mapsto & \bigcup\limits_{p \in \kleene \delta (q, w)} \delta(p, a)
		\end{array} $$
\end{definition}


\begin{definition}[langage reconnu par un AFN]
	Le langage reconnu / accepté par un AFN $A = \AFN$ est le langage
	$$ \lang A = \setdef {w \in \mots} {\exists q_0 \in I, \kleene \delta(q_0, w) \cap F \neq \emptyset} $$

\end{definition}

\subsection{Déterminisation d'un AFN}

Soit $A = \AFN$ un AFN, on considère l'AFD $A' = \antuple{\parts Q, I, F', \delta'}$ où
\begin{itemize}
	\item $F' = \setdef {q \in \parts Q} {q \cap F \neq \emptyset}$
	      \vspace{0.25cm}
	\item $ \begin{array}{rcl}
			      \delta' : \parts Q \times \alphabet & \to     & \parts Q                              \\
			      (Q, a)                              & \mapsto & \bigcup\limits_{p \in Q} \delta(p, a)
		      \end{array} $
\end{itemize}

\vspace{0.25cm}

Ce processus est appelé \textbf{déterminisation} d'un AFN et nous permet de transformer un AFN en un AFD équivalent.

\begin{exemple}
	Déterminisation d'un automate non déterministe :

	\begin{minipage}{0.4\textwidth}
		\begin{center}
			Automate non déterministe :
			\digraph[scale=0.65]{automateNonDet2}{
				rankdir=LR;

				node [shape=circle, style=filled, color=lightblue];
				q0 [label="q_0"];
				q1 [label="q_1"];

				start [shape=point];
				start -> q0;

				q0 -> q0 [label="a"];
				q0 -> q1 [label="a,b"];
				q1 -> q1 [label="a,b"];

				q1 [shape=doublecircle];
			}
		\end{center}
	\end{minipage}
	\begin{minipage}{0.6\textwidth}
		\begin{center}
			Automate déterminisé :
			\digraph[scale=0.5]{automateDet3}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="{q_0}"];
			q0q1 [label="{q_0, q_1}"];
			q1 [label="{q_1}"];

			start [shape=point];
			start -> q0;

			q0 -> q0q1 [label="a"];
			q0q1 -> q0q1 [label="q"];
			q0q1 -> q1 [label="b"];
			q0 -> q1 [label="b"];
			q1 -> q1 [label="a,b"];

			q0q1 [shape=doublecircle];
			q1 [shape=doublecircle];
			}
		\end{center}
	\end{minipage}
\end{exemple}


\begin{theorem}
	Soit $A$ un automate fini non déterministe avec des $\motvide$-transitions, alors il existe un automate fini non déterministe $A'$, \tq $\lang A = \lang {A'}$.
\end{theorem}

\subsection{Équivalence entre expressions rationnelles et automates finis déterministes}

\begin{theorem}[Injection des expressions rationnelles vers les automates finis déterministes]
	Soit $r \in \erat$, alors il existe un automate fini déterministe $N(r)$ \tq $\lang A = \lang r$.
\end{theorem}

\begin{proof}
	Nous allons construire un tel automate par induction sur la structure de $r$ cependant la preuve du fait que cet automate reconnaît le langage associé à $r$ est omise.
	Cette construction est appelée \textbf{construction de Thompson}.

	\begin{twoautomata}
		\digraph[scale=0.5]{thompson1}{
			rankdir=LR;
			node [shape=circle, style=filled, color=lightblue];
			q0 [label=" "];
			q1 [label=" "];
			start [shape=point];
			start -> q0; q0 -> q1 [label="ε"];
			q1 [shape=doublecircle];
		}
		\caption*{$N(\motvide)$}
	\end{twoautomata}
	\begin{twoautomata}
		\digraph[scale=0.5]{thompson2}{
			rankdir=LR;
			node [shape=circle, style=filled, color=lightblue];

			start [shape=point];
			q0 [label=" "];
			q1 [label=" ", shape=doublecircle];

			start -> q0;
			q0 -> q1 [style=invis];
		}
		\caption*{$N(\emptyset)$}
	\end{twoautomata}

	\begin{twoautomata}
		\digraph[scale=0.5]{thompson3}{
			rankdir=LR;
			node [shape=circle, style=filled, color=lightblue];
			q0 [label=" "];
			q1 [label=" "];
			start [shape=point];
			start -> q0; q0 -> q1 [label="a"];
			q1 [shape=doublecircle];
		}
		\caption*{$N(a), a \in \alphabet$}
	\end{twoautomata}
	\begin{twoautomata}
		\digraph[scale=0.5]{thompson4}{
		rankdir=LR;

		node [shape=circle, style=filled, color=lightblue];

		subgraph cluster_r {
		style=rounded;
		label="N(r)";
		color=lightcoral;

		nrin [label=" "];
		nrout [label=" "];
		nrin -> nrout [style=invis];
		}


		subgraph cluster_s {
		style=rounded;
		label="N(s)";
		color=lightgreen;

		nsin [label=" "];
		nsout [label=" "];
		nsin -> nsout [style=invis];
		}


		q0 [label=" "];
		q1 [label=" "];
		start [shape=point];

		start -> q0;
		q0 -> nrin [label="ε"];
		q0 -> nsin [label="ε"];

		nrout -> q1 [label="ε"];
		nsout -> q1 [label="ε"];

		q1 [shape=doublecircle];
		}

		\caption*{$N(r + s)$}
	\end{twoautomata}

	\begin{twoautomata}
		\digraph[scale=0.5]{thompson5}{
		rankdir=LR;

		node [shape=circle, style=filled, color=lightblue];

		subgraph cluster_r {
		style=rounded;
		label="N(r)";
		color=lightcoral;

		nrin [label=" "];
		nrout [label=" "];
		nrin -> nrout [style=invis];
		}

		subgraph cluster_s {
		style=rounded;
		label="N(s)";
		color=lightgreen;

		nsin  [label=" "];
		nsout [label=" "];
		nsin -> nsout [style=invis];
		}

		start [shape=point];

		start -> nrin;
		nrout -> nsin [label="ε"];
		nsout [shape=doublecircle];
		}
		\caption*{$N(rs)$}
	\end{twoautomata}
	\begin{twoautomata}
		\digraph[scale=0.5]{thompson6}{
		rankdir=LR;

		node [shape=circle, style=filled, color=lightblue];

		subgraph cluster_r {
		style=rounded;
		label="N(r)";
		color=lightcoral;

		nrin [label=" "];
		nrout [label=" "];
		nrin -> nrout [style=invis];
		}

		start [shape=point];

		q0 [label=" "];
		q1 [label=" "];
		start [shape=point];
		start -> q0;
		q0 -> q1 [label="ε"];
		q0 -> nrin [label="ε"];
		nrout -> nrin [label="ε"];
		nrout -> q1 [label="ε"];

		q1 [shape=doublecircle];
		}

		\caption*{$N(\kleene r)$}
	\end{twoautomata}

	En combinant ces constructions, on peut construire un automate fini non déterministe pour n'importe quelle
	expression rationnelle qui peut être determinisé pour obtenir un automate fini déterministe.

\end{proof}

\subsection{Morphismes d'automates}

\begin{definition}[Morphisme d'automates]
	Soit $A = \antuple{Q, q_0, F, \delta}$ et $ A' = \antuple{Q', q_0', F', \delta'} $ sur un alphabet $\alphabet$.
	Alors un morphisme d'automates $\phi: A \to A'$ est une fonction $\phi: Q \to Q'$ \tlq
	\begin{enumerate}
		\item $\phi (q_0) = q_0'$ \label{morph:1}
		\item $\forall q \in Q,\quad  \phi (q) \in F' \iff q \in F$ \label{morph:2}
		\item $\forall q \in Q, \forall a \in \alphabet,\quad \delta'(\phi (q), a) = \phi (\delta(q,a))$ \ie $\phi \circ \delta_a = \delta_a '\circ \phi$ \label{morph:3}
	\end{enumerate}

	% https://tex.stackexchange.com/questions/218274/how-can-i-draw-commutative-diagrams-in-latex
	\[
		\begin{tikzcd}
			Q \arrow{r}{\delta_a} \arrow[swap]{d}{\phi} & Q \arrow{d}{\phi} \\
			Q' \arrow{r}{\delta_a} & Q'
		\end{tikzcd}
	\]

\end{definition}


\begin{exercice}
	Soit $\phi : A \to A'$ un morphisme d'automates déterministes, alors $\lang A = \lang {A'}$
\end{exercice}

\begin{proof}
	\begin{eqnarray*}
		w \in \lang A &\iff& \kleene \delta (q_0, w) \in F \\
		&\iff& \phi (\kleene \delta (q_0, w)) \in F' \quad \text{par } \ref{morph:1} \\
		&\iff& \kleene \delta( \phi (q_0), w) \in F' \quad \text{par } \ref{morph:3} \\
		&\iff& \kleene \delta( q_0', w) \in F' \quad \text{par } \ref{morph:2} \\
		&\iff& w \in \lang {A'}
	\end{eqnarray*}
\end{proof}


\begin{definition}[Quotient d'un automate]
	Soit $L \subseteq \mots$ et $w \in \mots$. Le quotient $\quot w L$ est défini par
	$$ \quot w L = \setdef {u \in \mots} {wu \in L} $$
\end{definition}

\begin{definition}
	Soit $\AFD$ sur l'alphabet $\alphabet$ et $q \in Q$ alors on définit
	$$ L_q = \setdef {w \in \mots} {\kleene \delta (q,w) \in F} $$
\end{definition}


\begin{lemma}
	Soit A = $\AFD$ un automate fini déterministe, $q \in Q$ et $w \in \mots$. Si $\deltaS {q_0} w = q$ alors
	$L_q = \quot w \lang A$
\end{lemma}

\begin{proof}
	\begin{eqnarray*}
		w \in L_q &\iff& \deltaS q u \in F \\
		&\iff& \deltaS {\deltaS {q_0} w} u \in F \\
		&\iff& \deltaS {q_0} {wu} \in F \\
		&\iff& wu \in \lang A \\
		&\iff& u \in \quot w \lang A
	\end{eqnarray*}
\end{proof}

\begin{coro}
	Si $L \subseteq \mots$ est un langage régulier alors l'ensemble $\setdef {\quot w L} {w \in \mots}$ est fini.
\end{coro}

\begin{proof}
	Si $L = \lang A$, avec A = $\AFD$, alors $\abs {\setdef {\quot w L} {w \in \mots}} \leq \abs Q$. Car $\forall w \in \mots,$ $\quot w L$ est
	le langage accepté par $A$ à partir de l'état $\deltaS {q_0} w$.
\end{proof}

\begin{coro} \label{coro:2}
	Si $\AFN$ accepte un langage $L$ alors $\abs Q \geq $ \# quotients de $L$
\end{coro}

\begin{definition} [Automate des quotients]

	Soit $L \subseteq \mots$ un langage régulier, soit $Q = \setdef {\quot w L} {w \in \mots}$ et $\AFD$. Alors l'automate des quotients de $L$
	est défini par

	\begin{itemize}
		\item L'état initial est $\quot {\motvide} L$
		\item $F = \setdef {\quot w L} {w \in L}$
		\item $\delta (\quot w L, a) = \quot {(wa)} L$
	\end{itemize}
\end{definition}

\begin{remarque}
	Si $\quot w L = \quot {(w')} L$, alors $\quot {(wa)}L = \quot {(w'a)} L$.

	Soit $w,w' \in \mots$ \tq $\quot w L = \quot {(w')} L$. Soit $a \in \alphabet$ et $u \in \mots$,
	\begin{eqnarray*}
		u \in \quot {(wa)}L &\iff& wau \in L \\
		&\iff& au \in \quot w L \\
		&\iff& au \in \quot {w'} L \\
		&\iff& w'au \in L \\
		&\iff& (w'a)u \in L \\
		&\iff& u \in \quot {(w'a)}L
	\end{eqnarray*}
	Donc la fonction de transition $\delta$ de l'automate des quotients est bien définie.
\end{remarque}

\begin{prop}
	Étant donné un automate $A$ qui accepte le langage $L$, l'automate des quotients accepte aussi $L$ et il est minimal parmi les automates acceptant $L$.
\end{prop}

\begin{proof}
	$\deltaS L w = \quot w L$ et donc $\underbrace{\deltaS L w \in F}_{w \in \lang A} \iff w \in L$

	Et ainsi, par le corollaire \ref{coro:2}, l'automate des quotients est minimal.
\end{proof}

\begin{lemma}\label{lem:reach}
	Soit $L \subseteq \mots$ un langage régulier. Soit $A_L$ l'automate des quotients de $L$ et soit $B$ un autre automate acceptant $L$.
	Soit $\reach B$ un sous-automate accessible de $B$. Alors on a un morphisme surjectif (un quotient) d'automates $\reach B \twoheadrightarrow A_L$.

	\begin{tikzcd}[row sep=large]
		&\reach B \arrow[dr, hook] \arrow[dl, twoheadrightarrow] \\
		A_L & & B
	\end{tikzcd}

	Si $B = <T,t_0,F,\delta>$ alors $\reach B =  <T',t_0,F',\delta'>$ où
	\begin{itemize}
		\item $T' = \setdef {t \in T} {\exists w \in \mots, \deltaS {t_0} w = t}$
		\item $F' = F \cap T'$
		\item $\delta ' = \delta \cap (T' \times \alphabet \times T')$
	\end{itemize}
\end{lemma}


\begin{exercice}
	On définit $\phi : \reach B \to A$.

	Si $t \in T', \exists w \in \mots$ \tq $ t = \deltaS {t_0} w$
	On définit $\phi (t) = \quot w L$

	Montrer que $\phi$ est bien définie, \ie, $\phi t = \quot {w'} L \implies \quot w L = \quot {w'} L$.

	Vérifions $\phi$ surjective. Si $w \in \mots$ et $\quot w L$ est un état de $A_L$ alors $\phi (\deltaS {t_0} w) = \quot w L$

	Si $\abs B = \abs {A_L}$, alors $B$ est un automate accesible
	(Sinon $\abs A \leq \abs {\reach B} < \abs B \lightning)$.

	Donc $B = \reach B$

	De plus, le morphisme $\phi$ est une bijection et $\quot {\phi}$ est un morphisme d'automates.
	Donc $B \cong A_L$.

\end{exercice}


\subsection{Minimisation d'automates}

\begin{rappel}
	Pour tout langage rationnel $L$, il existe un unique (à isomorphisme près) automate déterministe minimal
	(avec le plus petit nombre possible d'états) qui reconnait $L$.
\end{rappel}

\begin{remarque}
	C'est n'est pas vrai pour les automates non-déterministes.


	\begin{twoautomata}
		\digraph[scale=0.5]{minex310}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="q_0"];
			q1 [label="q_1"];
			q2 [label="q_1"];

			start [shape=point];

			start -> q0;
			q0 -> q1 [label="b"];
			q1 -> q1 [label="a"];
			q1 -> q2 [label="a"];
			q2 -> q1 [label="b"];
			q2 [shape=doublecircle];
		}
		\caption*{$(ba^+)^+$}
	\end{twoautomata}
	\begin{twoautomata}
		\digraph[scale=0.5]{minex311}{
			rankdir=LR;

			node [shape=circle, style=filled, color=lightblue];
			q0 [label="q_0"];
			q1 [label="q_1"];
			q2 [label="q_1"];

			start [shape=point];

			start -> q0;
			q0 -> q1 [label="b"];
			q1 -> q2 [label="a"];
			q2 -> q2 [label="a"];
			q2 -> q1 [label="b"];
			q2 [shape=doublecircle];
		}
		\caption*{$(ba^+)^+$}

	\end{twoautomata}
\end{remarque}

L'automate des résiduels de L est l'automate minimal reconnaissant L.


Nous allons voir trois algorithmes de minimisation différents:
\begin{itemize}
	\item Algorithme de Brzozowski
	\item Algorithme de Moore
	\item Algorithme de Hopcroft
\end{itemize}


\subsubsection{Algorithme de Brzozowski}

\begin{prop}
	Si $A$ est un automate déterministe et accesible, \ie, $\forall q \in Q, \exists \text{ un chemin } q_0 \to q$,
	et  $A^ {\sim} = \detA (\mirr(A)) $ est l'automate obtenu en déterminisant l'automate miroir de $A$. Alors
	$A^{\sim}$ est l'automate minimal qui reconnait $\mirror {\lang A}$.
\end{prop}


\begin{proof}
	Soit $A = (Q, q_0, T)$, $L = \lang A$. $\mirr (A) = (Q, T, q_0), M = \lang {\mirr (A)} = \mirror L$.

	On note $X \cdot u$ et $\delta (X,u)$, $X$ étant un ensemble d'états et $u$ un mot, l'ensemble $\bigcup\limits_{q \in X} \delta (q,a)$.

	Nous allons montrer que $A^{\sim}$ est l'automate minimal pour $M$. Pour cela, il suffit de montrer que $A^{\sim}$
	est isomorphe à l'automate des résiduels de $M$.

	Pour cela, il faut \mq si $u$ et $v$ sont deux mots quelconques \tq $\quot u M = \quot v M$, alors $T \cdot u =  T \cdot v$ dans $A^{\sim}$.

	Soit $p$ un état de $T \cdot u$. Puisque $A$ est accesible, il existe un chemin de $q_0 \to p$ dans $A$, et donc il existe un chemin $p \to q_0$ dans $\mirr(A)$.
	Soit $w$ l'étiquette de ce chemin, alors le mot $uw$ est l'étiquette d'un chemin réussi de $\mirr (A)$. En conséquence, $uw \in M$.

	Mais $uw\in M \iff w \in \quot u M \iff w\in \quot v M \iff vw \in M$.

	Donc $vw$ est l'étiquette d'un chemin réussi $\Gamma$ dans $\mirr (A)$. Étant donné que $A$ est déterministe, tout chemin aboutissant dans $q_0$
	et dont l'étiquette a $w$ comme suffixe doit passer par $p$.

	On en  déduit que $p \in Tv$.
\end{proof}


\begin{coro}
	Soit $A$ un automate, alors l'automate $\detA (\mirr (\detA(\mirr (A))))$ est l'automate minimal pour $\lang A$.
\end{coro}

\begin{proof}
	En effet,

	$\underbrace{\detA (\mirr (
			\underbrace{\detA(\mirr (A))}_{\text{Un automate déterministe et accesible qui reconnait }\mirror {\lang A}}
			))}_{\text{la proposition précédente garantit que cet automate est minimal pour }  \mirror{\mirror {\lang A} } = \lang A}
	$
\end{proof}

\begin{complexite}
	La complexité de l'algorithme est en $O(2^n)$. En effet, la dernière détermination exécutée travaille sur un automate de taille au plus $2^n$
	et produit un automate de taille $2^n$. Sa complexité reste aussi en $O(2^n)$.
\end{complexite}


\begin{remarque}
	Alors que d'autres algorithmes, \tq Moore, ont une complexité polynomiale, Brzozowski à différence des autres, ne nécessite pas
	que l'automate donné soit déterministe.
\end{remarque}

\subsubsection{Algorithme de Moore}


\begin{definition}[Congruence d'automates]
	Soit $A = (Q,q_0,T,S)$ un automate déterministe et soit $\sim$ un relation d'équivalence définie sur l'ensemble $Q$. On dit que
	$\sim$ est une congruence si $\sim$ satisfait les conditions suivantes.
	\begin{enumerate}
		\item Compatibilité aves les transitions: Si $q \sim q'$ alors $\forall a \in \alphabet, \delta (q,a) \sim \delta (q',a)$
		\item Saturation de $A$: Si $q \sim q'$ alors $q \in T \iff q' \in T$
	\end{enumerate}
\end{definition}


\begin{definition}
	Si $A = \AFD$ est un AFD et $\sim$ une congruence définie dur $Q$. On définit l'automate quotient :
	$$ A/\sim = (Q',q_0',T',\delta') $$

	avec \begin{itemize}
		\item $Q' = \setdef {[q]} {q\in Q}$ (chaque état est étiqueté par une classe d'équivalence)
		\item $q_0' = [q_0]$
		\item $T' =\setdef  {[q]} {q \in T}$
		\item $\delta'([q], a) = [p]$ \ssi $q \in [qa]$
	\end{itemize}

\end{definition}

\begin{prop}
	Si $A$ est un automate déterministe et $\sim$ une congruence sur $A$, alors $\lang A = \lang {A/\sim}$
\end{prop}


\begin{definition}[Congruence de Nerode]

	Si $A = (Q, \set {q_0}, T, \delta)$ un AFD. $\forall q, q' \in Q$ on définit $q \cong q' \iff L_q = L_{q'}$.
\end{definition}

\begin{rappel}
	$L_q = \setdef w {\deltaS q w \in T}$.
	Donc
	\begin{eqnarray*}
		q \cong q' \iff L_q = L_{q'} &\iff& \forall w, w \in L_q \mssi w \in L_q \\
		&\iff& \forall w, \deltaS q w \in T \mssi  \deltaS {q'} w \in T
	\end{eqnarray*}

	On en déduit que
	\begin{equation}\label{eq:congnot}
		q \not\cong q' \iff \exists w, \deltaS q w \in T \et \deltaS {q'} w \notin T
	\end{equation}
	où $\deltaS q w \notin T$ et $\deltaS q' w \in T$ sont deux états non équivalents, dits \emph{séparables}.
\end{rappel}

Si $q$ et $q'$ sont séparables et $w$ est un mot qui satisfait \ref{eq:congnot}, on dira que $w$ \emph{sépare} $q$ et $q'$.


Pour calculer la congruence de Nérode on introduit une famille de congruences :

\begin{equation}
	\cong_i, i  \in \N, q \cong_i q' \iff \forall w, \abs w \leq i \implies \deltaS q w \in T \iff  \deltaS {q'} w \in T
\end{equation}


\begin{definition}
	Définition alternative

	\begin{itemize}
		\item $q \cong_0 q' \mssi q\in T \iff q' \in T$
		\item $q \cong_{i+1} q' \mssi q \cong_{i} q' \et  \forall a \in \alphabet, \delta (q,a) \cong_i \delta (q', a)$
	\end{itemize}
\end{definition}

\begin{remarque}
	Par définition $\cong_{i+1}$ induit une partition de $Q$ au moins aussi fine que celle induite par $\cong_i$.

	Les classes de $\cong_{i+1}$ sont obtenues en partitionnant des classes de $\cong_i$.
\end{remarque}

\begin{remarque}
	Puisque $Q$ est fini, le processus de partitionnement doit se stabiliser. Autrement dit,

	$$\exists k \in \N^*, \text{\tq} \cong_{k} \ = \ \cong_{k+j} \forall j \in \N^* $$
\end{remarque}


\begin{prop}
	Si $k \in \N$ \tq $ \cong_k \ = \ \cong_{k+j} \forall j \in \N$, alors $\cong_k \ = \ \cong$
\end{prop}

\begin{proof}
	Soit $q,q' \in Q$, $q \cong_k q'$, \mq $L_q = L_{q'}$. Exercice.
\end{proof}

\begin{definition}[Algorithme de Moore]
	L'algorithme consiste à créer un automate à partir des classes d'équivalence sur $\cong$.
	Les états sont les classes d'équivalence, on obtient les transitions en regardant le comportement
	d'un représentant de la classe et les états finaux sont les classes qui ont un représentant qui est un état final.
\end{definition}


\begin{complexite}
	L'algorithme effectue $n$ étapes et chaque étape dépense $O(n)$, donc sa complexité est en $O(n^2)$ (au pire).

	En fait, en moyenne $O(n \log n)$ (David, 2010) et meme $O(n \log \log n)$.
\end{complexite}


\subsection{Monoïdes}

\begin{definition}[Monoïde]
	Un monoide est un tuple $(Mm \times, 1)$ où $M$ est un ensemble, $\times : M \times M \to M$ est une operation binaire sur $M$,
	$1\in M$ \tq
	\begin{enumerate}
		\item $\times$ est une opération  associative ($\forall x,y,z \in M , x \times (y \times z) = (x \times y) \times z$)
		\item $1$ est un élément neutre pout $\times$, \cad, $\forall x \in M, 1 \times x = x \times 1 = x$
	\end{enumerate}
\end{definition}

\begin{exemple}
	\begin{itemize}
		\item $(\N, +, 0)$
		\item $(\mots, \cdot, \motvide)$
		\item $(\Z, +, 0)$ est un monoïde, mais aussi un groupe car tout element possède un symétrique.
		\item Si $Q$ est un ensemble, alors $(Q ^ Q, \circ, \text{id})$
	\end{itemize}
\end{exemple}


\begin{definition}[Morphisme de monoïdes]
	Soit $(M,\times_M, 1_M)$ et $(N,\times_N, 1_N)$ son des monoïdes. Une fonction $h :  M \to N$ est appelé un morphisme de monoïdes \ssi
	\begin{enumerate}
		\item $h(1_M) = 1_M \reason{$h$ preserve l'élément neutre}$
		\item $\forall x, y \in M, h (x \times_M y) = h(x) \times_N h(y) \reason{$h$ preserve la multiplication}$
	\end{enumerate}
\end{definition}


\begin{prop}
	Soit $\alphabet$ un ensemble et $(M,\cdot, 1)$ un monoïde. Soit $f : \alphabet \to M$ une fonction. Il existe
	un unique morphisme de monoïdes $\bar f : \mots \to M$ \tq $\bar f (a) =  f (a) \forall a \in \alphabet$.

	TODO: diagrame commutatif.
\end{prop}


\begin{proof}
	\begin{itemize}
		\item Existence:

		      Soit $w\in \mots$ de la forme $\motDecomp w n$ où $a_i \in \alphabet$.

		      Soit $\bar f (w) =^{def} f(w_1) \cdot \cdots \cdot f(w_n)$ et $\bar f (\motvide) = 1_M$. Alors pour $a\in \alphabet, \bar f (a) = f (a)$.
		      Si $\motDecomp w n$ et $\motDecomp v m \in \mots$.
		      \begin{eqnarray*}
			      \bar (wv) = \bar f(\decomp w n \decomp w m) &=& f(w_1) \cdot \cdots \cdot f(w_n) \cdot f(v_1) \cdot \cdots \cdot f(v_m) \\
			      &=& \left( f(w_1) \cdot \cdots \cdot f(w_n)\right)\left( \cdot f(v_1) \cdot \cdots \cdot f(v_m) \right)\\
			      &=& \bar f(\decomp w n) \bar f (\decomp w m) \\
			      &=& \bar f(w) \bar f (w)
		      \end{eqnarray*}

		      Donc $\forall w, v \in \mots, \bar f (wv) = \bar f (w)\bar f(w) \et \bar f (\motvide) = 1_M$ et ainsi, $\bar f$ est un morphisme de monoïdes.


		\item Unicité:

		      Si $h : \mots \to M$ est un morphisme de monoïdes \tq $h(a) = f(a) \forall a \in \mots$. Alors $h(\motvide) = 1_M$.

		      Comme $h$ preserve la multiplication on a
		      $h (\decomp a n) = h(a_1) \cdots h(a_n) = f(a_1) \cdots f(a_n) = \bar f (\decomp a n)$
		      Et donc $h = \bar f$
	\end{itemize}
\end{proof}

On dit que $\mots$ est le monoïde librement engendré sur $\alphabet$

\begin{definition}[Librement engendré]
	$H$ et librement engendré par sur $\alphabet$ si
	$$\forall f : \alphabet \to M \text{ où } M  \text { est un monoïde }, \exists ! \bar f : H \to M \et i : \alphabet \to H, \bar f \circ i   = f $$

	$ H \cong \mots$
\end{definition}

\begin{exemple}
	TODO: Exemple
\end{exemple}

\begin{definition}[Reconnaissance par monoïdes]
	Soit $\alphabet$ un alphabet finit. Soit $L \subseteq \mots$ un langage et soit $\phi : \mots \to M$ un morphisme de monoïdes où $(M, \circ, 1_M)$ est un monoïde fini. On dit que
	$\phi$ reconnait $L$ \ssi il existe $P \subseteq N$ \tq $L = \quot {\phi} (P)$, \cad $L = \setdef {w \in \mots} (\phi (w) \in P)$.
\end{definition}

\begin{exercice}
	$\phi$ reconnaît $L$ \ssi $L = \quot {\phi} (\phi (L))$.
\end{exercice}

\begin{prop}
	Soit $L \subseteq \mots$ un langage sur l'alphabet $\alphabet$. Alors $L$ est reconnaissable \ssi $L$ est reconnu par un morphisme de monoïdes $\phi : \mots \to M$ où $M$ est fini.
\end{prop}


\begin{proof}
	\begin{itemize}
		\item $\Rightarrow$

		      Soit $\phi : \mots \to M$ un morphisme de monoïdes avec $M$ fini qui reconnait le langage $L$.
		      $\exists P \subseteq M, L = \quot {\phi} (P)$.

		      Soit $A$ l'automate suivant : $\antuple {M, 1_M, P, \delta}$ où

		      $$ \begin{array}{rcl}
				      \delta : M \times \alphabet & \to     & M                \\
				      (m,a)                       & \mapsto & m \cdot \phi (a)
			      \end{array} $$

		      On peut montrer par induction sur la longueur du mot que

		      $$ \begin{array}{rcl}
				      \delta ^* : M \times \mots & \to     & M        \\
				      (1_M, w)                   & \mapsto & \phi (w)
			      \end{array} $$

		      $A$ accepte le mot $w$ \ssi $\deltaS {1_M} w \in P$ \ssi $\phi (w) \in P$ \ssi $w \in \quot {\phi} = L$.

		      Donc $A$ accepte le langage $L$


		\item $\Leftarrow$

		      Soit $\AFD$ un automate déterministe complet qui accept $L$.
		      Soit

		      $$ \begin{array}{rcl}
				      \phi : \mots & \to     & Q^Q        \reason{$(Q^Q, \circ,\text{id}_Q $ est bien un monoïde} \\
				      \phi (w)(q)  & \mapsto & \deltaS q w
			      \end{array} $$

		      On a bien :
		      \begin{itemize}
			      \item $Q^Q$ est un monoïde fini.
			      \item $\phi (\motvide) (q) = \deltaS q {\motvide}$, donc $\begin{array}{rcl}
					            \phi (\motvide) : Q & \to     & Q \\
					            q                   & \mapsto & q
				            \end{array}
			            $%TODO: improve this
			            est la fonction identité sur $Q$ et donc $\phi$ preserve l'identité.
			      \item $\phi (w) \circ \phi (w') = \phi (ww'), \ \forall w, w' \in \mots$ car
			            $\deltaS {\deltaS q w} {w'} = \deltaS q {ww'}$.

			            Soit $P \subseteq Q^Q$ défini par $P \setdef {f : Q \to Q} {f(q_0)\in F}$.

			            \begin{eqnarray*}
				            \quot {\phi} (P) &=& \setdef {w \in \mots} {\phi (w) \in P} \\
				            &=& \setdef {w \in \mots} {\phi (w) (q_0)\in F} \\
				            &=& \setdef {w \in \mots} {\deltaS {q_0} w \in F}\\
				            &=& \setdef {w \in \mots} {w \text { est accepté par } A}\\
				            &=& L
			            \end{eqnarray*}
		      \end{itemize}

		      Donc $L$ est reconnu par $\phi$.
	\end{itemize}
\end{proof}


\begin{definition}
	On va appeler $\phi (\mots)\subseteq Q^Q$ le \textbf{monoïde de transition de l'automate} $A$
\end{definition}


\begin{definition}[Congruence]
	Soit $(M, \cdot, 1_M)$ un monoïde. Une congruence sir $M$ est une relation d'équivalent $\sim \subseteq M \times M$ \tlq
	$$\forall m,m', \ m \sim m' \iff \forall, n,r \in M, n\cdot m \cdot r \sim n \cdot m' \cdot r$$
\end{definition}



\begin{definition}[Congruence syntaxique d'un langage]
	Soit $L \subseteq \mots$ un langage, Soit $\sim_L \subseteq \mots \times \mots$ la relation d'équivalence défini par :
	$$ w \sim_L w' \mssi \forall u,v \mots, uwv \in L \iff u w' v \in L$$
\end{definition}

\begin{prop}
	$\sim_L$ est une congruence sur $\mots$.
\end{prop}

\begin{proof}
	Exercice.
\end{proof}


\begin{prop}
	Soit $\monoide$ un monoïde et $\sim \subseteq M \times M$ est une congruence sur $M$, alors $M/\sim = \setdef {[m]} {m \in M}$.
	Où $[m]$ note la classe d'équivalence de $m$ par rapport à $\sim$.

	$M/\sim$ est un monoïde et $ \begin{array}{rcl}
			h : M & \to     & M   \\
			m     & \mapsto & [m]
		\end{array} $ est un morphisme de monoïdes.
\end{prop}

\begin{proof}
	$(M/\sim, \cdot, [1_M])$ est un monoïde où $[m][m'] = [mm']$.

	À montrer que cette multiplication est bin définie,\cad si $m_2 \sim m \et m_2' \sim m'$ alors $m_2 m_2' \sim m m'$ :
	\begin{eqnarray*}
		m_2 &\sim& m \\
		m_2' &\sim& m' \\
		1_M \cdot  m_2 \cdot m_2' &\sim& 1_M \cdot m \cdot m_2' \reason{car $\sim$ est une congruence} \\
		m_2 \cdot m_2' &\sim&  m \cdot m_2' \\
		\text{Mais } m \cdot m_2' &\sim& m \cdot m' \reason{car $\sim$ est une congruence} \\
		\implies m_2 \cdot m_2' &\sim& m \cdot m'
	\end{eqnarray*}

	Donc la multiplication sur $M/\sim$ est bine define.


	$[1_M]$ est un élément neutre car $[m]\cdot [1_M] = [m \cdot 1_M] = [m]$ et pareil pour $[1_M]\cdot [m] = [m]$.

	$h$ est donc un morphisme de monoïdes:

	\begin{itemize}
		\item  $h(1_M) = [1_M]$
		\item  $h(m\cdot n) = [m \cdot n] = [m] \cdot [n] = h(m) \cdot h(n)$
	\end{itemize}
\end{proof}

\begin{remarque}
	$h$ est un \textbf{morphisme surjectif} (aussi appelé un quotient).
\end{remarque}

\begin{definition}
	Soit $L \subseteq \mots$ un langage et soit $\sim_L$ la congruence syntaxique sur $\mots$.
	Le monoïde quotient $\mots / \sim_L$ est appelé le monoïde syntaxique de $L$.
\end{definition}

\begin{prop}
	Ales les notations ci-dessus, $L$ est reconnu par le morphisme
	$ \begin{array}{rcl}
			\phi : \mots & \to     & \;ots \\
			w            & \mapsto & [w]
		\end{array} $.
\end{prop}



\begin{remarque}\label{rem:quot_mono}
	Si $w \in L$ et $w' \sim_L w$ alors $w' \in L$ Parce que  $w' \sim_L w$.
	Comme $\motvide w \motvide \in L$ et donc  $\motvide w' \motvide \iff w' \in L$.

\end{remarque}

\begin{proof}
	Soit $P \subseteq \mots / \sim_L$ donné par $P = \setdef {[w]} {w \in L}$.

	On doit \mq $L = \quot {\phi} (P)$, \cad, $L = \setdef {w \in \mots} {\phi (w) \in P}$

	En utilisant la remarque \ref{rem:quot_mono} on a que si $ w\in L$ alors $[w ] \subseteq L$.

	On en conclut que
	$$ L = \bigcup_{w \in L} [w]    \iff L = \quot {\phi} (P) $$
\end{proof}


\begin{prop}
	Le monoïde syntaxique a une propriété similaire à \ref{lem:reach}:
	$\forall \monoide$ monoïde qui reconnait un langage $L$, on a le diagramme suivant:

	\begin{tikzcd}[row sep=large]
		&(N, \cdot , 1_N) \arrow[dr, hook] \arrow[dl, twoheadrightarrow] \\
		(\mots / \sim_L, \cdot,  [\motvide]) & & (M, \cdot, 1_M)
	\end{tikzcd}
\end{prop}

\begin{terminologie}
	On dit que le monoïde syntaxique de $L$ divise tout monoïde qui accepte $L$.
\end{terminologie}




\begin{lemma}
	Si $N$ divise $M$ et $N$ reconnait un langage $L$ alors $M$ reconnait $L$ :

\end{lemma}

\begin{proof}

	\begin{tikzcd}[row sep=large]
		&T \arrow[dr, hook] \arrow[dl, twoheadrightarrow] \\
		N & & M
	\end{tikzcd}
	$\phi : \mots \to N $ et $P \subseteq N$ \tq $L = \quot {\phi} (P)$

	Exercice : \mq on peut construire $\phi'' : \mots \to M$ qui reconnait $L$.
\end{proof}


\begin{prop}
	Un monoïde  $M$ reconnait  un langage $L$ \ssi le monoïde syntaxique $\mots / \sim_L$ divise $M$.
\end{prop}

\begin{proof}

	\begin{itemize}
		\item $\Leftarrow$

		      $\mots / \sim_L$ reconnait $L$. Par le lemme, si $\mots / \sim_L$ divise $M$, alors $M$ reconnait $L$.

		\item $\Rightarrow$

		      Supposons que $M$ reconnait $L$. Donc on a $\phi : \mots \to M$ et $P \subseteq M$ avec $\quot {\phi} (P) = L$.
		      Soit $N = \phi (\mots)$ l'image directe de $\mots$ par $\phi$.

		      Alors $M \hookrightarrow N$ est un sous-monoide de $M$.

		      Je voudrais avoir un quotient $N \twoheadrightarrow \mots/\sim$.

		      Si $n \in N$ alors $\exists w \in \mots$ \tq $\phi(w) = n$. On défini $h(n) = [w]$. Il faut \mq
		      \begin{enumerate}
			      \item $h$ est bien défini (si $\phi (w') = \phi (w) \implies [w] = [w']$). \label{prop:recon1}
			      \item $h$ est un morphisme de monoïdes.
			      \item $h$ est surjectif.
		      \end{enumerate}

		      Montrons cela:
		      \begin{itemize}
			      \item \ref{prop:recon1}: Supposons que $\phi(w) = \phi (w')$.

			            On veut \mq $[w]=[w']$m \cad $w \sim_L w'$, \cad $\forall u,v \in \mots uwv \in L \iff uw'v \in L$.

			            Soient $u,v \in \mots$.
			            \begin{eqnarray*}
				            uwv \in L &\iff& \phi (uwv) \in P\\
				            &\iff& \phi (u)\phi(w) \phi(v) \in P \reason{car $\phi$ est un morphisme} \\
				            &\iff& \phi (u)\phi(w') \phi(v) \in P \reason{car $\phi (w) = \phi (w')$ } \\
				            &\iff& \phi (uw'v) \in P\\
				            &\iff& uw'v \in L
			            \end{eqnarray*}

			            Donc $w \sim_L w'$.
		      \end{itemize}
	\end{itemize}
\end{proof}



